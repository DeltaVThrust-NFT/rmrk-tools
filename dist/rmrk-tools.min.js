!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@polkadot/util-crypto"),require("@polkadot/util"),require("url")):"function"==typeof define&&define.amd?define(["exports","@polkadot/util-crypto","@polkadot/util","url"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).rmrkTools={},e.util_crypto,e.util)}(this,(function(e,t,n){"use strict";function r(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var o=r(t);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}const c=window;function l(){return 0!==Object.keys(c.injectedWeb3).length}function d(e){throw new Error(`${e}: web3Enable(originName) needs to be called before ${e}`)}function u(e,n,r){return n.map((({address:n,genesisHash:o,name:i})=>({address:t.encodeAddress(t.decodeAddress(n),r),meta:{genesisHash:o,name:i,source:e}})))}c.injectedWeb3=c.injectedWeb3||{};let h=l(),f=null;async function m({ss58Format:e}={}){if(!f)return d("web3Accounts");const t=[],n=await f;(await Promise.all(n.map((async({accounts:t,name:n})=>{try{return u(n,await t.get(),e)}catch(e){return[]}})))).forEach((e=>{t.push(...e)}));const r=t.map((({address:e})=>e));return console.log(`web3Accounts: Found ${t.length} address${1!==t.length?"es":""}: ${r.join(", ")}`),t}async function w(e){if(!f)return d("web3FromSource");const t=await f,n=e&&t.find((({name:t})=>t===e));if(!n)throw new Error(`web3FromSource: Unable to find an injected ${e}`);return n}var b,p,g=Object.freeze({__proto__:null,get isWeb3Injected(){return h},get web3EnablePromise(){return f},web3Enable:function(e){if(!e)throw new Error("You must pass a name for your app to the web3Enable function");var t;return t=()=>function(e){return Promise.all(Object.entries(c.injectedWeb3).map((([t,{enable:n,version:r}])=>Promise.all([Promise.resolve({name:t,version:r}),n(e).catch((e=>{console.error(`Error initializing ${t}: ${e.message}`)}))]))))}(e).then((e=>e.filter((e=>!!e[1])).map((([e,t])=>(t.accounts.subscribe||(t.accounts.subscribe=e=>(t.accounts.get().then(e).catch(console.error),()=>{})),a(a({},e),t)))))).catch((()=>[])).then((e=>{const t=e.map((({name:e,version:t})=>`${e}/${t}`));return h=l(),console.log(`web3Enable: Enabled ${e.length} extension${1!==e.length?"s":""}: ${t.join(", ")}`),e})),f=new Promise((e=>{"complete"===document.readyState?e(t()):window.addEventListener("load",(()=>e(t())))})),f},web3Accounts:m,web3AccountsSubscribe:async function(e,{ss58Format:t}={}){if(!f)return d("web3AccountsSubscribe");const n={},r=(await f).map((({accounts:{subscribe:r},name:o})=>r((r=>{n[o]=r,e(Object.entries(n).reduce(((e,[n,r])=>(e.push(...u(n,r,t)),e)),[]))}))));return()=>{r.forEach((e=>{e()}))}},web3FromSource:w,web3FromAddress:async function(e){if(!f)return d("web3FromAddress");const r=await m();let o;if(e){const i=t.decodeAddress(e);o=r.find((e=>n.u8aEq(t.decodeAddress(e.address),i)))}if(!o)throw new Error(`web3FromAddress: Unable to find injected ${e}`);return w(o.meta.source)},web3ListRpcProviders:async function(e){const{provider:t}=await w(e);return t?t.listProviders():(console.warn(`Extension ${e} does not expose any provider`),null)},web3UseRpcProvider:async function(e,t){const{provider:n}=await w(e);if(!n)throw new Error(`Extension ${e} does not expose any provider`);return{meta:await n.startProvider(t),provider:n}}});
/*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */function E(e,t,n,r){return new(n||(n=Promise))((function(o,i){function s(e){try{c(r.next(e))}catch(e){i(e)}}function a(e){try{c(r.throw(e))}catch(e){i(e)}}function c(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}c((r=r.apply(e,t||[])).next())}))}class I{constructor(e,t,n,r,o,i,s){this.changes=[],this.block=e,this.name=t,this.max=n,this.issuer=r,this.symbol=o,this.id=i,this.metadata=s}mint(){if(this.block)throw new Error("An already existing collection cannot be minted!");return`RMRK::MINT::${I.V}::${encodeURIComponent(JSON.stringify({name:this.name,max:this.max,issuer:this.issuer,symbol:this.symbol.toUpperCase(),id:this.id,metadata:this.metadata}))}`}change_issuer(e){if(0===this.block)throw new Error("This collection is new, so there's no issuer to change. If it has been deployed on chain, load the existing collection as a new instance first, then change issuer.");return`RMRK::CHANGEISSUER::${I.V}::${this.id}::${e}`}addChange(e){return this.changes.push(e),this}getChanges(){return this.changes}static generateId(e,t){if(!e.startsWith("0x"))throw new Error("This is not a valid pubkey, it does not start with 0x");return e.substr(2,10)+e.substring(e.length-8)+"-"+t.toUpperCase()}static fromRemark(e,t){t||(t=0);const n=e.split("::");try{if("RMRK"!=n[0].toUpperCase())throw new Error("Invalid remark - does not start with RMRK");if("MINT"!=n[1])throw new Error("The op code needs to be MINT, is "+n[1]);if(n[2]!=I.V)throw new Error(`This remark was issued under version ${n[2]} instead of ${I.V}`);const e=decodeURIComponent(n[3]),r=JSON.parse(e);if(!r)throw new Error(`Could not parse object from: ${e}`);if(void 0===r.metadata||!r.metadata.startsWith("ipfs")&&!r.metadata.startsWith("http"))throw new Error("Invalid metadata - not an HTTP or IPFS URL");if(void 0===r.name)throw new Error("Missing field: name");if(void 0===r.max)throw new Error("Missing field: max");if(void 0===r.issuer)throw new Error("Missing field: issuer");if(void 0===r.symbol)throw new Error("Missing field: symbol");if(void 0===r.id)throw new Error("Missing field: id");return new this(t,r.name,r.max,r.issuer,r.symbol,r.id,r.metadata)}catch(t){return console.error(t.message),console.log(`MINT error: full input was ${e}`),t.message}}load_metadata(){return E(this,void 0,void 0,(function*(){return this.loadedMetadata?this.loadedMetadata:{}}))}}I.V="RMRK1.0.0",function(e){e[e.null=0]="null",e[e.boost_number=1]="boost_number",e[e.number=2]="number",e[e.boost_percentage=3]="boost_percentage"}(b||(b={}));class T{constructor(e,t,n,r,o,i,s,a){this.changes=[],this.block=e,this.collection=t,this.name=n,this.instance=r,this.transferable=o,this.sn=i,this.data=a,this.metadata=s,this.owner="",this.reactions={}}getId(){if(!this.block)throw new Error("This token is not minted, so it cannot have an ID.");return`${this.block}-${this.collection}-${this.instance}-${this.sn}`}addChange(e){return this.changes.push(e),this}mintnft(){if(this.block)throw new Error("An already existing NFT cannot be minted!");return`RMRK::MINTNFT::${T.V}::${encodeURIComponent(JSON.stringify({collection:this.collection,name:this.name,instance:this.instance,transferable:this.transferable,sn:this.sn,metadata:this.metadata}))}`}send(e){if(!this.block)throw new Error("You can only send an existing NFT. If you just minted this, please load a new, \n        separate instance as the block number is an important part of an NFT's ID.");return`RMRK::SEND::${T.V}::${this.getId()}::${e}`}static checkDataFormat(e){return!0}static fromRemark(e,t){t||(t=0);const n=e.split("::");try{if("RMRK"!=n[0].toUpperCase())throw new Error("Invalid remark - does not start with RMRK");if("MINTNFT"!=n[1])throw new Error("The op code needs to be MINTNFT, is "+n[1]);if(n[2]!=T.V)throw new Error(`This remark was issued under version ${n[2]} instead of ${T.V}`);const e=decodeURIComponent(n[3]),r=JSON.parse(e);if(!r)throw new Error(`Could not parse object from: ${e}`);if((void 0===r.metadata||!r.metadata.startsWith("ipfs")&&!r.metadata.startsWith("http"))&&void 0===r.data)throw new Error("Invalid metadata (not an HTTP or IPFS URL) and missing data");if(r.data&&T.checkDataFormat(r.data),void 0===r.name)throw new Error("Missing field: name");if(void 0===r.collection)throw new Error("Missing field: collection");if(void 0===r.instance)throw new Error("Missing field: instance");if(void 0===r.transferable)throw new Error("Missing field: transferable");if(void 0===r.sn)throw new Error("Missing field: sn");return new this(t,r.collection,r.name,r.instance,r.transferable,r.sn,r.metadata,r.data)}catch(t){return console.error(t.message),console.log(`MINTNFT error: full input was ${e}`),t.message}}list(e){if(!this.block)throw new Error("You can only list an existing NFT. If you just minted this, please load a new, \n        separate instance as the block number is an important part of an NFT's ID.");return`RMRK::LIST::${T.V}::${this.getId()}::${e>0?e:"cancel"}`}buy(){if(!this.block)throw new Error("You can only buy an existing NFT. If you just minted this, please load a new, \n        separate instance as the block number is an important part of an NFT's ID.");return`RMRK::BUY::${T.V}::${this.getId()}`}consume(){if(!this.block)throw new Error("You can only consume an existing NFT. If you just minted this, please load a new, \n        separate instance as the block number is an important part of an NFT's ID.");return`RMRK::CONSUME::${T.V}::${this.getId()}`}load_metadata(){return E(this,void 0,void 0,(function*(){return this.loadedMetadata?this.loadedMetadata:{}}))}}T.V="RMRK1.0.0",function(e){e[e.null=0]="null",e[e.boost_number=1]="boost_number",e[e.number=2]="number",e[e.boost_percentage=3]="boost_percentage"}(p||(p={}));class ${constructor(e,t){this.issuer=e,this.id=t}static fromRemark(e){const t=e.split("::");try{if("RMRK"!=t[0])throw new Error("Invalid remark - does not start with RMRK");if(t[2]!=$.V)throw new Error(`Version mismatch. Is ${t[2]}, should be ${$.V}`);if("CHANGEISSUER"!=t[1])throw new Error("The op code needs to be CHANGEISSUER, is "+t[1]);if(void 0===t[3]||null==t[4])throw new Error("Cound not find ID or new issuer")}catch(t){return console.error(t.message),console.log(`CHANGEISSUER error: full input was ${e}`),t.message}return new $(t[4],t[3])}}$.V="RMRK1.0.0";class y{constructor(e,t){this.recipient=t,this.id=e}static fromRemark(e){const t=e.split("::");try{if("RMRK"!=t[0])throw new Error("Invalid remark - does not start with RMRK");if(t[2]!=y.V)throw new Error(`Version mismatch. Is ${t[2]}, should be ${y.V}`);if("SEND"!=t[1])throw new Error("The op code needs to be SEND, is "+t[1]);if(void 0===t[3]||null==t[4])throw new Error("Cound not find ID or recipient")}catch(t){return console.error(t.message),console.log(`SEND error: full input was ${e}`),t.message}return new y(t[3],t[4])}}y.V="RMRK1.0.0";class k{constructor(e,t){this.unicode=t,this.id=e}static fromRemark(e){const t=e.split("::");try{if("RMRK"!=t[0])throw new Error("Invalid remark - does not start with RMRK");if(t[2]!=k.V)throw new Error(`Version mismatch. Is ${t[2]}, should be ${k.V}`);if("EMOTE"!=t[1])throw new Error("The op code needs to be EMOTE, is "+t[1]);if(void 0===t[3]||null==t[4])throw new Error("Cound not find ID or unicode")}catch(t){return console.error(t.message),console.log(`EMOTE error: full input was ${e}`),t.message}return new k(t[3],t[4])}}k.V="RMRK1.0.0";const N=function(e){console.log(JSON.stringify(e,null,2))};var R;!function(e){e.BUY="BUY",e.LIST="LIST",e.MINT="MINT",e.MINTNFT="MINTNFT",e.SEND="SEND",e.EMOTE="EMOTE",e.CHANGEISSUER="CHANGEISSUER"}(R||(R={}));const v={consolidator:class{constructor(e){this.adapter=e,this.invalidCalls=[],this.collections=[],this.nfts=[]}findExistingCollection(e){return this.collections.find((t=>t.id===e))}updateInvalidCalls(e,t){const n={op_type:e,block:t.block,caller:t.caller};return function(e,t){this.invalidCalls.push(Object.assign(Object.assign({},n),{object_id:e,message:t}))}}mint(e){console.log("Instantiating collection");const r=this.updateInvalidCalls(R.MINT,e).bind(this),o=I.fromRemark(e.remark,e.block);if("string"==typeof o)return r(e.remark,`[${R.MINT}] Dead before instantiation: ${o}`),!0;const i=t.decodeAddress(e.caller),s=I.generateId(n.u8aToHex(i),o.symbol);return this.findExistingCollection(o.id)?(r(o.id,`[${R.MINT}] Attempt to mint already existing collection`),!0):s.toLowerCase()!==o.id.toLowerCase()?(r(o.id,`Caller's pubkey ${n.u8aToHex(i)} (${s}) does not match generated ID`),!0):(this.collections.push(o),!1)}mintNFT(e){console.log("Instantiating nft");const t=this.updateInvalidCalls(R.MINTNFT,e).bind(this),n=T.fromRemark(e.remark,e.block);if("string"==typeof n)return t(e.remark,`[${R.MINTNFT}] Dead before instantiation: ${n}`),!0;const r=this.findExistingCollection(n.collection);if(!r)return t(n.getId(),`NFT referencing non-existant parent collection ${n.collection}`),!0;if(n.owner=r.issuer,e.caller!=n.owner)return t(n.getId(),`Attempted issue of NFT in non-owned collection. Issuer: ${r.issuer}, caller: ${e.caller}`),!0;return this.nfts.find((e=>{const t=e.getId().split("-");t.shift();const r=t.join("-"),o=n.getId().split("-");o.shift();return r===o.join("-")}))?(t(n.getId(),`[${R.MINTNFT}] Attempt to mint already existing NFT`),!0):""===n.owner?(t(n.getId(),`[${R.MINTNFT}] Somehow this NFT still doesn't have an owner.`),!0):(this.nfts.push(n),!1)}send(e){console.log("Instantiating send");const t=y.fromRemark(e.remark),n=this.updateInvalidCalls(R.SEND,e).bind(this);if("string"==typeof t)return n(e.remark,`[${R.SEND}] Dead before instantiation: ${t}`),!0;const r=this.nfts.find((e=>{const n=e.getId().split("-");n.shift();const r=n.join("-"),o=t.id.split("-");o.shift();return r===o.join("-")}));return r?r.owner!=e.caller?(n(t.id,`[${R.SEND}] Attempting to send non-owned NFT ${t.id}, real owner: ${r.owner}`),!0):(r.addChange({field:"owner",old:r.owner,new:t.recipient,caller:e.caller,block:e.block}),r.owner=t.recipient,!1):(n(t.id,`[${R.SEND}] Attempting to send non-existant NFT ${t.id}`),!0)}emote(e){console.log("Instantiating emote");const t=k.fromRemark(e.remark),n=this.updateInvalidCalls(R.EMOTE,e).bind(this);if("string"==typeof t)return n(e.remark,`[${R.EMOTE}] Dead before instantiation: ${t}`),!0;const r=this.nfts.find((e=>e.getId()===t.id));if(!r)return n(t.id,`[${R.EMOTE}] Attempting to emote on non-existant NFT ${t.id}`),!0;const o=r.reactions[t.unicode].indexOf(e.caller,0);return o>-1?r.reactions[t.unicode].splice(o,1):r.reactions[t.unicode].push(e.caller),!1}changeIssuer(e){console.log("Instantiating an issuer change");const t=$.fromRemark(e.remark),n=this.updateInvalidCalls(R.CHANGEISSUER,e).bind(this);if("string"==typeof t)return n(e.remark,`[${R.CHANGEISSUER}] Dead before instantiation: ${t}`),!0;const r=this.collections.find((e=>e.id===t.id));return r?e.caller!=r.issuer?(n(t.id,`Attempting to change issuer of collection ${t.id} when not issuer!`),!0):(r.addChange({field:"issuer",old:r.issuer,new:t.issuer,caller:e.caller,block:e.block}),r.issuer=t.issuer,!1):(n(t.id,`This ${R.CHANGEISSUER} remark is invalid - no such collection with ID ${t.id} found before block ${e.block}!`),!0)}consolidate(){const e=this.adapter.getRemarks();for(const t of e)switch(console.log("=============================="),console.log("Remark is: "+t.remark),t.interaction_type){case R.MINT:if(this.mint(t))continue;break;case R.MINTNFT:if(this.mintNFT(t))continue;break;case R.SEND:if(this.send(t))continue;break;case R.BUY:case R.LIST:break;case R.EMOTE:if(this.emote(t))continue;break;case R.CHANGEISSUER:if(this.changeIssuer(t))continue;break;default:console.error("Unable to process this remark - wrong type: "+t.interaction_type)}N(this.nfts),N(this.collections),console.log(this.invalidCalls)}}},M={util_crypto:o,dappex:g};e.c100=I,e.n100=T,e.polkadot=M,e.rmrk=v,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=rmrk-tools.min.js.map
