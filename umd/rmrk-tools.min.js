!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@polkadot/api"),require("@polkadot/util"),require("url"),require("@polkadot/keyring")):"function"==typeof define&&define.amd?define(["exports","@polkadot/api","@polkadot/util","url","@polkadot/keyring"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).rmrkTools={},e.api,e.util,e.url,e.keyring)}(this,(function(e,t,n,r,o){"use strict";class i{constructor(e,t,n,r,o,i,s){this.changes=[],this.block=e,this.name=t,this.max=n,this.issuer=r,this.symbol=o,this.id=i,this.metadata=s}mint(){if(this.block)throw new Error("An already existing collection cannot be minted!");return`RMRK::MINT::${i.V}::${encodeURIComponent(JSON.stringify({name:this.name,max:this.max,issuer:this.issuer,symbol:this.symbol.toUpperCase(),id:this.id,metadata:this.metadata}))}`}change_issuer(e){if(0===this.block)throw new Error("This collection is new, so there's no issuer to change. If it has been deployed on chain, load the existing collection as a new instance first, then change issuer.");return`RMRK::CHANGEISSUER::${i.V}::${this.id}::${e}`}addChange(e){return this.changes.push(e),this}getChanges(){return this.changes}static generateId(e,t){if(!e.startsWith("0x"))throw new Error("This is not a valid pubkey, it does not start with 0x");return e.substr(2,10)+e.substring(e.length-8)+"-"+t.toUpperCase()}static fromRemark(e,t){t||(t=0);const n=e.split("::");try{if("RMRK"!=n[0].toUpperCase())throw new Error("Invalid remark - does not start with RMRK");if("MINT"!=n[1])throw new Error("The op code needs to be MINT, is "+n[1]);if(n[2]!=i.V)throw new Error(`This remark was issued under version ${n[2]} instead of ${i.V}`);const e=decodeURIComponent(n[3]),r=JSON.parse(e);if(!r)throw new Error(`Could not parse object from: ${e}`);if(void 0===r.metadata||!r.metadata.startsWith("ipfs")&&!r.metadata.startsWith("http"))throw new Error("Invalid metadata - not an HTTP or IPFS URL");if(void 0===r.name)throw new Error("Missing field: name");if(void 0===r.max)throw new Error("Missing field: max");if(void 0===r.issuer)throw new Error("Missing field: issuer");if(void 0===r.symbol)throw new Error("Missing field: symbol");if(void 0===r.id)throw new Error("Missing field: id");return new this(t,r.name,r.max,r.issuer,r.symbol,r.id,r.metadata)}catch(t){return console.error(t.message),console.log(`MINT error: full input was ${e}`),t.message}}async load_metadata(){return this.loadedMetadata?this.loadedMetadata:{}}}var s,a,l;i.V="RMRK1.0.0",function(e){e[e.null=0]="null",e[e.boost_number=1]="boost_number",e[e.number=2]="number",e[e.boost_percentage=3]="boost_percentage"}(s||(s={}));class c{constructor(e,t,n,r,o,i,s,a){this.changes=[],this.block=e,this.collection=t,this.name=n,this.instance=r,this.transferable=o,this.sn=i,this.data=a,this.metadata=s,this.owner="",this.reactions={}}getId(){if(!this.block)throw new Error("This token is not minted, so it cannot have an ID.");return`${this.block}-${this.collection}-${this.instance}-${this.sn}`}addChange(e){return this.changes.push(e),this}mintnft(){if(this.block)throw new Error("An already existing NFT cannot be minted!");return`RMRK::MINTNFT::${c.V}::${encodeURIComponent(JSON.stringify({collection:this.collection,name:this.name,instance:this.instance,transferable:this.transferable,sn:this.sn,metadata:this.metadata}))}`}send(e){if(!this.block)throw new Error("You can only send an existing NFT. If you just minted this, please load a new, \n        separate instance as the block number is an important part of an NFT's ID.");return`RMRK::SEND::${c.V}::${this.getId()}::${e}`}static checkDataFormat(e){return!0}static fromRemark(e,t){t||(t=0);const n=e.split("::");try{if("RMRK"!=n[0].toUpperCase())throw new Error("Invalid remark - does not start with RMRK");if("MINTNFT"!=n[1])throw new Error("The op code needs to be MINTNFT, is "+n[1]);if(n[2]!=c.V)throw new Error(`This remark was issued under version ${n[2]} instead of ${c.V}`);const e=decodeURIComponent(n[3]),r=JSON.parse(e);if(!r)throw new Error(`Could not parse object from: ${e}`);if((void 0===r.metadata||!r.metadata.startsWith("ipfs")&&!r.metadata.startsWith("http"))&&void 0===r.data)throw new Error("Invalid metadata (not an HTTP or IPFS URL) and missing data");if(r.data&&c.checkDataFormat(r.data),void 0===r.name)throw new Error("Missing field: name");if(void 0===r.collection)throw new Error("Missing field: collection");if(void 0===r.instance)throw new Error("Missing field: instance");if(void 0===r.transferable)throw new Error("Missing field: transferable");if(void 0===r.sn)throw new Error("Missing field: sn");return new this(t,r.collection,r.name,r.instance,r.transferable,r.sn,r.metadata,r.data)}catch(t){return console.error(t.message),console.log(`MINTNFT error: full input was ${e}`),t.message}}list(e){if(!this.block)throw new Error("You can only list an existing NFT. If you just minted this, please load a new, \n        separate instance as the block number is an important part of an NFT's ID.");return`RMRK::LIST::${c.V}::${this.getId()}::${e>0?e:"cancel"}`}buy(){if(!this.block)throw new Error("You can only buy an existing NFT. If you just minted this, please load a new, \n        separate instance as the block number is an important part of an NFT's ID.");return`RMRK::BUY::${c.V}::${this.getId()}`}consume(){if(!this.block)throw new Error("You can only consume an existing NFT. If you just minted this, please load a new, \n        separate instance as the block number is an important part of an NFT's ID.");return`RMRK::CONSUME::${c.V}::${this.getId()}`}async load_metadata(){return this.loadedMetadata?this.loadedMetadata:{}}}c.V="RMRK1.0.0",function(e){e[e.null=0]="null",e[e.boost_number=1]="boost_number",e[e.number=2]="number",e[e.boost_percentage=3]="boost_percentage"}(a||(a={}));class d{constructor(e,t){this.issuer=e,this.id=t}static fromRemark(e){const t=e.split("::");try{if("RMRK"!=t[0])throw new Error("Invalid remark - does not start with RMRK");if(t[2]!=d.V)throw new Error(`Version mismatch. Is ${t[2]}, should be ${d.V}`);if("CHANGEISSUER"!=t[1])throw new Error("The op code needs to be CHANGEISSUER, is "+t[1]);if(void 0===t[3]||null==t[4])throw new Error("Cound not find ID or new issuer")}catch(t){return console.error(t.message),console.log(`CHANGEISSUER error: full input was ${e}`),t.message}return new d(t[4],t[3])}}d.V="RMRK1.0.0";class h{constructor(e,t){this.recipient=t,this.id=e}static fromRemark(e){const t=e.split("::");try{if("RMRK"!=t[0])throw new Error("Invalid remark - does not start with RMRK");if(t[2]!=h.V)throw new Error(`Version mismatch. Is ${t[2]}, should be ${h.V}`);if("SEND"!=t[1])throw new Error("The op code needs to be SEND, is "+t[1]);if(void 0===t[3]||null==t[4])throw new Error("Cound not find ID or recipient")}catch(t){return console.error(t.message),console.log(`SEND error: full input was ${e}`),t.message}return new h(t[3],t[4])}}h.V="RMRK1.0.0";class u{constructor(e,t){this.unicode=t,this.id=e}static fromRemark(e){const t=e.split("::");try{if("RMRK"!=t[0])throw new Error("Invalid remark - does not start with RMRK");if(t[2]!=u.V)throw new Error(`Version mismatch. Is ${t[2]}, should be ${u.V}`);if("EMOTE"!=t[1])throw new Error("The op code needs to be EMOTE, is "+t[1]);if(void 0===t[3]||null==t[4])throw new Error("Cound not find ID or unicode")}catch(t){return console.error(t.message),console.log(`EMOTE error: full input was ${e}`),t.message}return new u(t[3],t[4])}}u.V="RMRK1.0.0",function(e){e.BUY="BUY",e.LIST="LIST",e.MINT="MINT",e.MINTNFT="MINTNFT",e.SEND="SEND",e.EMOTE="EMOTE",e.CHANGEISSUER="CHANGEISSUER"}(l||(l={}));const f=function(e){console.log(JSON.stringify(e,null,2))},m=(e,t)=>{const r=n.hexToString(e.value),o=r.split("::");return o.length<3?(console.error(`Invalid RMRK in block ${t}: ${r}`),!1):{type:o[1],version:parseFloat(o[2])?o[2]:"0.1"}};var g=Object.freeze({__proto__:null,getApi:async e=>{const n=new t.WsProvider(e);return t.ApiPromise.create({provider:n})},getLatestBlock:async e=>(await e.rpc.chain.getHeader()).number.toNumber(),getLatestFinalizedBlock:async e=>{const t=await e.rpc.chain.getFinalizedHead(),n=await e.rpc.chain.getHeader(t);return 0===n.number.toNumber()&&(console.error("Unable to retrieve finalized head - returned genesis block"),process.exit(1)),n.number.toNumber()},deeplog:f,stringIsAValidUrl:e=>{try{return new r.URL(e),!0}catch(e){return!1}},prefixToArray:function(e){const t=[],r=e.split(",");for(const e of r)0===e.indexOf("0x")?t.push(e):t.push(n.stringToHex(e));return t},getRemarksFromBlocks:e=>{const t=[];for(const r of e)for(const e of r.calls){if("system.remark"!==e.call)continue;const o=m(e,r.block);if(!o)continue;let i;switch(o.type){case l.MINTNFT:case l.MINT:i=decodeURI(n.hexToString(e.value));break;default:i=n.hexToString(e.value)}const s={block:r.block,caller:e.caller,interaction_type:o.type,version:o.version,remark:i};t.push(s)}return t}});e.Consolidator=class{constructor(e){e&&(this.adapter=e),this.invalidCalls=[],this.collections=[],this.nfts=[]}findExistingCollection(e){return this.collections.find((t=>t.id===e))}updateInvalidCalls(e,t){const n={op_type:e,block:t.block,caller:t.caller};return function(e,t){this.invalidCalls.push(Object.assign(Object.assign({},n),{object_id:e,message:t}))}}mint(e){console.log("Instantiating collection");const t=this.updateInvalidCalls(l.MINT,e).bind(this),r=i.fromRemark(e.remark,e.block);if("string"==typeof r)return t(e.remark,`[${l.MINT}] Dead before instantiation: ${r}`),!0;const s=o.decodeAddress(e.caller),a=i.generateId(n.u8aToHex(s),r.symbol);return this.findExistingCollection(r.id)?(t(r.id,`[${l.MINT}] Attempt to mint already existing collection`),!0):a.toLowerCase()!==r.id.toLowerCase()?(t(r.id,`Caller's pubkey ${n.u8aToHex(s)} (${a}) does not match generated ID`),!0):(this.collections.push(r),!1)}mintNFT(e){console.log("Instantiating nft");const t=this.updateInvalidCalls(l.MINTNFT,e).bind(this),n=c.fromRemark(e.remark,e.block);if("string"==typeof n)return t(e.remark,`[${l.MINTNFT}] Dead before instantiation: ${n}`),!0;const r=this.findExistingCollection(n.collection);if(!r)return t(n.getId(),`NFT referencing non-existant parent collection ${n.collection}`),!0;if(n.owner=r.issuer,e.caller!=n.owner)return t(n.getId(),`Attempted issue of NFT in non-owned collection. Issuer: ${r.issuer}, caller: ${e.caller}`),!0;return this.nfts.find((e=>{const t=e.getId().split("-");t.shift();const r=t.join("-"),o=n.getId().split("-");o.shift();return r===o.join("-")}))?(t(n.getId(),`[${l.MINTNFT}] Attempt to mint already existing NFT`),!0):""===n.owner?(t(n.getId(),`[${l.MINTNFT}] Somehow this NFT still doesn't have an owner.`),!0):(this.nfts.push(n),!1)}send(e){console.log("Instantiating send");const t=h.fromRemark(e.remark),n=this.updateInvalidCalls(l.SEND,e).bind(this);if("string"==typeof t)return n(e.remark,`[${l.SEND}] Dead before instantiation: ${t}`),!0;const r=this.nfts.find((e=>{const n=e.getId().split("-");n.shift();const r=n.join("-"),o=t.id.split("-");o.shift();return r===o.join("-")}));return r?r.owner!=e.caller?(n(t.id,`[${l.SEND}] Attempting to send non-owned NFT ${t.id}, real owner: ${r.owner}`),!0):(r.addChange({field:"owner",old:r.owner,new:t.recipient,caller:e.caller,block:e.block}),r.owner=t.recipient,!1):(n(t.id,`[${l.SEND}] Attempting to send non-existant NFT ${t.id}`),!0)}emote(e){console.log("Instantiating emote");const t=u.fromRemark(e.remark),n=this.updateInvalidCalls(l.EMOTE,e).bind(this);if("string"==typeof t)return n(e.remark,`[${l.EMOTE}] Dead before instantiation: ${t}`),!0;const r=this.nfts.find((e=>e.getId()===t.id));if(!r)return n(t.id,`[${l.EMOTE}] Attempting to emote on non-existant NFT ${t.id}`),!0;const o=r.reactions[t.unicode].indexOf(e.caller,0);return o>-1?r.reactions[t.unicode].splice(o,1):r.reactions[t.unicode].push(e.caller),!1}changeIssuer(e){console.log("Instantiating an issuer change");const t=d.fromRemark(e.remark),n=this.updateInvalidCalls(l.CHANGEISSUER,e).bind(this);if("string"==typeof t)return n(e.remark,`[${l.CHANGEISSUER}] Dead before instantiation: ${t}`),!0;const r=this.collections.find((e=>e.id===t.id));return r?e.caller!=r.issuer?(n(t.id,`Attempting to change issuer of collection ${t.id} when not issuer!`),!0):(r.addChange({field:"issuer",old:r.issuer,new:t.issuer,caller:e.caller,block:e.block}),r.issuer=t.issuer,!1):(n(t.id,`This ${l.CHANGEISSUER} remark is invalid - no such collection with ID ${t.id} found before block ${e.block}!`),!0)}consolidate(e){var t;const n=e||(null===(t=this.adapter)||void 0===t?void 0:t.getRemarks())||[];for(const e of n)switch(console.log("=============================="),console.log("Remark is: "+e.remark),e.interaction_type){case l.MINT:if(this.mint(e))continue;break;case l.MINTNFT:if(this.mintNFT(e))continue;break;case l.SEND:if(this.send(e))continue;break;case l.BUY:case l.LIST:break;case l.EMOTE:if(this.emote(e))continue;break;case l.CHANGEISSUER:if(this.changeIssuer(e))continue;break;default:console.error("Unable to process this remark - wrong type: "+e.interaction_type)}f(this.nfts),f(this.collections),console.log(this.invalidCalls)}},e.c100=i,e.fetchRemarks=async(e,t,n,r)=>{const o=[];for(let i=t;i<=n;i++){if(i%1e3==0){const e=new Date;console.log(`Block ${i} at time ${e.toTimeString()}`),i%5e3==0&&console.log(`Currently at ${o.length} remarks.`)}const t=await e.rpc.chain.getBlockHash(i),n=await e.rpc.chain.getBlock(t),s=[];if(void 0===n.block){console.error("block.block is undefined for block "+i),f(n);continue}let a=0;e:for(const o of n.block.extrinsics){if(o.isEmpty||!o.isSigned){a++;continue}const{method:{args:n,method:l,section:c}}=o;if("system"===c&&"remark"===l){const e=n.toString();r.some((t=>e.startsWith(t)))&&s.push({call:"system.remark",value:e,caller:o.signer.toString()})}else if("utility"===c&&("batch"===l||"batchAll"==l)){const l=n[0];let c=!1;if(l.forEach((e=>{"system"===e.section&&"remark"===e.method&&r.some((t=>e.args.toString().startsWith(t)))&&(c=!0)})),c){if((await e.query.system.events.at(t)).filter((({phase:e,event:t})=>e.isApplyExtrinsic&&e.asApplyExtrinsic.eq(a)&&"BatchInterrupted"===t.method.toString())).length){console.log(`Skipping batch ${i}-${a} due to BatchInterrupted`),a++;continue e}l.forEach((e=>{s.push({call:`${e.section}.${e.method}`,value:e.args.toString(),caller:o.signer.toString()})}))}}a++}s.length&&o.push({block:i,calls:s})}return o},e.n100=c,e.utils=g,Object.defineProperty(e,"__esModule",{value:!0})}));
